# MySQL

## Создание и удаление базы данных
```SQL
SHOW DATABASES имя_базы_даных; - Вывести все базы данных

CREATE DATABASE имя_базы_даных; - Создать базу данных, если она есть вернет ошибку

CREATE DATABASE IF NOT EXISTS имя_базы_даных; - Создать базу данных если ее нет

USE имя_базы_даных; - Установка базы данных

DROP DATABASE имя_базы_даных; - Удалить базу данных. Если ее нет вернет ошибку

DROP DATABASE [IF EXISTS] имя_базы_даных; - Удалить базу данных если она есть
```

## Создание и удаление таблиц
>**CREATE TABLE** название_таблицы
>
>(название_столбца1 тип_данных атрибуты_столбца1,
>
> ................................................
>
> название_столбцаN тип_данных атрибуты_столбцаN,
>
> атрибуты_уровня_таблицы
>)

```SQL
CREATE TABLE Customers (Id INT);
```

`RENAME TABLE старое_название TO новое_название;` - переименование таблицы

`TRUNCATE TABLE название_таблицы;` - удалить данные в таблице

`DROP TABLE название_таблицы;` - удаление таблицы

## Атрибуты столбцов и таблиц
`PRIMARY KEY` - задает первичный ключ таблицы

`AUTO_INCREMENT` - позволяет указать, что значение столбца будет автоматически увеличиваться при добавлении новой строки

`UNIQUE` - казывает, что столбец может хранить только уникальные значения

`NULL и NOT NULL` - указывает что столбец может или не может принемать null

`DEFAULT` - указывает значение по умолчанию

`CHECK` - задает ограничение для диапазона значений, которые могут храниться в столбце
```SQL
CHECK((Age >0 AND Age<100) AND (Email !='') AND (Phone !=''))
```
`CONSTRAINT` - можно задать имя для ограничений на уровне таблицы с помощю CHECK

## Внешние ключи **FOREIGN KEY**
Cтолбец текущей таблицы ссылается на столбец Id таблицы Customers:
```SQL
FOREIGN KEY (CustomerId)  REFERENCES Customers (Id)
```
`ON DELETE и ON UPDATE` - спомощью выражение можно установить действия, которые выполняются соответственно при удалении и изменении связанной строки из главной таблицы

>**ДЕЙСТВИЯ:**
> 
>`CASCADE`: автоматически удаляет или изменяет строки из зависимой таблицы при удалении или изменении связанных строк в главной таблице.
> 
>`SET NULL`: при удалении или обновлении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL)
>
>`RESTRICT`: отклоняет удаление или изменение строк в главной таблице при наличии связанных строк в зависимой таблице.
>
>`NO ACTION`: то же самое, что и `RESTRICT`.
> 
>`SET DEFAULT`: при удалении связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение по умолчанию, которое задается с помощью атрибуты `DEFAULT`. Несмотря на то, что данная опция в принципе доступна, однако движок `InnoDB` не поддерживает данное выражение.

`CONSTRAINT` - установка имени ограничений

>Смысл установки имен ограничений заключается в том, что впоследствии через эти  имена мы сможем управлять ограничениями - удалять или изменять их.
```SQL
CONSTRAINT customers_pk PRIMARY KEY(Id), - установка имени для ограничения PRIMARY KEY.
```
> Установить имя можно для ограничений `PRIMARY KEY`, `CHECK`, `UNIQUE`, а также `FOREIGN KEY`.

## Изменение таблиц и столбцов

>`ALTER TABLE название_таблицы` - Если таблица уже была ранее создана, и ее необходимо изменить, то для этого применяется данная команда
```SQL
ADD Address VARCHAR(50) NULL; - добавление нового столбца

DROP COLUMN Address; - удаление столбца

ALTER COLUMN Age SET DEFAULT 22; - изменение значение по умолчанию столбца Age

MODIFY COLUMN FirstName CHAR(100) NULL; - Изменим тип данных у столбца FirstName на CHAR(100) и установим для него атрибут NULL

ADD FOREIGN KEY(CustomerId) REFERENCES Customers(Id); - добавление внешнего ключа

DROP FOREIGN KEY orders_customers_fk; - удаление внешнего ключа по ограничению

ADD PRIMARY KEY (Id); - добавление первичного ключа

DROP PRIMARY KEY; - удаление первичного ключа
```

## Добавление данных. Команда *INSERT*
```mysql
INSERT Products(ProductName, Manufacturer, ProductCount, Price) VALUES ('iPhone X', 'Apple', 5, 76000);
- добавление в таблицу Products с столбца данные
```

>После выражения `INSERT INTO` в скобках можно указать список столбцов через запятую, в которые надо добавлять данные, и в конце после слова `VALUES` скобках перечисляют добавляемые для столбцов значения.
```sql
INSERT Products(ProductName, Manufacturer, Price, ProductCount) 
VALUES ('iPhone 8', 'Apple', 51000, 3),
        ('P20 Lite', 'Huawei', 34000, 4),
        ('Galaxy S8', 'Samsung', 46000, 2); - добавление в таблицу Products с столбца данные сразу на три строки
```

## Выборка данных. Команда *SELECT*
>**SELECT** список_столбцов **FROM** имя_таблицы
```sql
SELECT * FROM Products; - взять все из таблицы Products
SELECT ProductName, Price FROM Products; - взеть данные в столбцах ProductName и Price  из таблици Products
SELECT ProductName, Price * ProductCount FROM Products; - запрос с выполнением арефмитического выражения меджу столбцами 
    Price и ProductCount
SELECT ProductName AS Title, Price * ProductCount AS TotalSum FROM Products; - С помощью оператора AS можно определить его псевдоним
```

## Фильтрация данных. Оператор *WHERE*
>WHERE условие

>**SELECT** * **FROM** Products **WHERE** Manufacturer **=** 'Samsung';

>**ОПЕРАЦИИ СТАВНЕНИЕ:**
> 
>`=` - сравнение на равенство
> 
>`!=` - сравнение на неравенство
>
>`<>` - сравнение на неравенство
> 
>`<` - меньше чем
> 
>`>` - больше чем
> 
> `<=` - меньше чем или равно
> 
> `>=` - больше чем или равно
> 
```sql
SELECT * FROM Products WHERE Price * ProductCount > 100000; - запрос где произведение Price и 
ProductCount больше 100000
```

>ЛОГИЧЕСКИЕ ОПЕРАЦИИ:
> 
>`AND`: операция логического **И**
> 
>`OR`: операция логического **ИЛИ**
> 
>`NOT`: операция логического отрицания
```sql
SELECT * FROM Products WHERE Manufacturer = 'Samsung' AND Price > 50000
- выберем все товары, у которых производитель Samsung и одновременно цена больше 50000
```
```sql
SELECT * FROM Products WHERE Manufacturer ='Samsung' OR NOT (Price > 30000 AND ProductCount > 2);
- с помощью скобок можно переопределить приоретет операции
```

## Обновление данных. Команда *UPDATE*
Команда UPDATE применяется для обновления уже имеющихся строк. Она имеет следующий формальный синтаксис
```sql
UPDATE имя_таблицы SET столбец1 = значение1, столбец2 = значение2, ... столбецN = значение [WHERE условие_обновления]
```
Например, увеличим у всех товаров цену на 3000:
```sql
UPDATE Products SET Price = Price + 3000;
```
Используем выражение WHERE и изменим название производителя с `Samsung` на `Samsung Inc.`:
```sql
UPDATE Products SET Manufacturer = 'Samsung Inc.' WHERE Manufacturer = 'Samsung';
```
Также можно обновлять сразу несколько столбцов:
```sql
UPDATE Products SET Manufacturer = 'Samsung',
                    ProductCount = ProductCount + 3
WHERE Manufacturer = 'Samsung Inc.';
```

При обновлении вместо конкретных значений и выражений мы можем использовать ключевые слова `DEFAULT` и `NULL` для установки соответственно значения по умолчанию или `NULL`:
```sql
UPDATE Products SET ProductCount= DEFAULT WHERE Manufacturer = 'Huawei';
```

## Удаление данных. Команда *DELETE*
Команда DELETE удаляет данные из БД. Она имеет следующий формальный синтаксис:
```sql
DELETE FROM имя_таблицы [WHERE условие_удаления]
```
Например, удалим строки, у которых производитель - Huawei:
```sql
DELETE FROM Products WHERE Manufacturer='Huawei';
```
Или удалим все товары, производителем которых является Apple и которые имеют цену меньше 60000:
```sql
DELETE FROM Products WHERE Manufacturer='Apple' AND Price < 60000;
```
Если необходимо вовсе удалить все строки вне зависимости от условия, то условие можно не указывать:
```sql
DELETE FROM Products;
```

## Выборка уникальных значений. Оператор *DISTINCT*

С помощью оператора DISTINCT можно выбрать уникальные данные по определенным столбцам.

Выберем всех производителей:
```sql
SELECT Manufacturer FROM Products;
```
Однако при таком запросе производители повторяются. Теперь применим оператор DISTINCT для выборки уникальных значений:
```sql
SELECT DISTINCT Manufacturer FROM Products;
```
Также мы можем задавать выборку уникальных значений по нескольким столбцам:
```sql
SELECT DISTINCT Manufacturer, ProductCount FROM Products;
```

## Операторы фильтрации `IN`, `NOT`, `BETWEEN`, `LIKE и REGEXP`, `IS NULL`

**Оператор `IN` определяет набор значений, которые должны иметь столбцы:**

>`WHERE` выражение [NOT] `IN` (выражение)

Выражение в скобках после IN определяет набор значений. Этот набор может вычисляться динамически на основании, например, еще одного запроса, либо это могут быть константные значения.

Например, выберем товары, у которых производитель либо Samsung, либо Xiaomi, либо Huawei:
```sql
SELECT * FROM Products WHERE Manufacturer IN ('Samsung', 'HTC', 'Huawei');
```
Оператор NOT, наоборот, позволяет выбрать все строки, столбцы которых не имеют определенных значений:
```sql
SELECT * FROM Products WHERE Manufacturer NOT IN ('Samsung', 'HTC', 'Huawei');
```
**Оператор `BETWEEN` определяет диапазон значений с помощью начального и конечного значения, которому должно соответствовать выражение:**
>`WHERE` выражение [NOT] `BETWEEN` начальное_значение `AND` конечное_значение

Например, получим все товары, у которых цена от 20 000 до 50 000 (начальное и конечное значения также включаются в диапазон):

```sql
SELECT * FROM Products WHERE Price BETWEEN 20000 AND 50000;
```
Если надо, наоборот, выбрать те строки, которые не попадают в данный диапазон, то добавляется оператор `NOT`:
```sql
SELECT * FROM Products WHERE Price NOT BETWEEN 20000 AND 50000;
```
**Оператор `LIKE` принимает шаблон строки, которому должно соответствовать выражение.**
>`WHERE` выражение [NOT] `LIKE` шаблон_строки

Для определения шаблона могут применяться ряд специальных символов подстановки:

>+ `%` : соответствует любой подстроке, которая может иметь любое количество символов, при этом подстрока может и не содержать ни одного символа
>
>Например, выражение `WHERE` ProductName `LIKE` 'Galaxy%' соответствует таким значениям как "Galaxy Ace 2" или "Galaxy S7"
>
>+ `_` : соответствует любому одиночному символу
>
>Например, выражение `WHERE` ProductName `LIKE` 'Galaxy S_' соответствует таким значениям как "Galaxy S7" или "Galaxy S8".

Применим оператор LIKE:
```sql
SELECT * FROM Products WHERE ProductName LIKE 'iPhone%';
```
**`REGEXP` позволяет задать регулярное выражение, которому должно соответствовать значение столбца. В этом плане `REGEXP` представляет более изощренный и комплексный способ фильтрации, нежели оператор `LIKE`. `REGEXP` имеет похожий синтаксис:**

>`WHERE` выражение [NOT] `REGEXP` регулярное выражение

Регулярное выражение может принимать следующие специальные символы:

>+ `^`: указывает на начало строки
>
>+ `$`: указывает на конец строки
>
>+ `.`: соответствует любому одиночному символу
>
>+ `[символы]`: соответствует любому одиночному символу из скобок
>
>+ `[начальный_символ-конечный_символ]`: соответствует любому одиночному символу из диапазона символов
>
>+ `|`: отделяет два шаблона строки, и значение должно соответствовать одну из этих шаблонов

Примеры REGEXP:

>`WHERE` ProductName `REGEXP` `'Phone'`: строка должна содержать "Phone", например, iPhone X, Nokia Phone N, iPhone
>
>`WHERE` ProductName `REGEXP` `'^Phone'`: строка должна начинаться с "Phone", например, Phone 34, PhoneX
>
>`WHERE` ProductName `REGEXP` `'Phone$'`: строка должна заканчиваться на "Phone", например, iPhone, Nokia Phone
>
>`WHERE` ProductName `REGEXP` `'iPhone [78]'`;: строка должна содержать либо iPhone 7, либо iPhone 8
>
>`WHERE` ProductName `REGEXP` `'iPhone [6-8]'`;: строка должна содержать либо iPhone 6, либо iPhone 7, либо iPhone 8

Например, найдем товары, названия которых содержат либо "Phone", либо "Galaxy":
```sql
SELECT * FROM Products WHERE ProductName REGEXP 'Phone|Galaxy';
```

**Оператор `IS NULL` позволяет выбрать все строки, столбцы которых имеют значение `NULL`:**
```sql
SELECT * FROM Products WHERE ProductCount IS NULL;
```
С помощью добавления оператора `NOT` можно, наоброт, выбрать строки, столбцы которых не имеют значения `NULL`:
```sql
SELECT * FROM Products WHERE ProductCount IS NOT NULL;
```

## Сортировка. `ORDER BY`

Оператор ORDER BY сортируют значения по одному или нескольких столбцам. Например, упорядочим выборку из таблицы Products по столбцу Price:
```sql
SELECT * FROM Products ORDER BY Price;
```
Также можно производить упорядочивание данных по псевдониму столбца, который определяется с помощью оператора AS:
```sql
SELECT ProductName, ProductCount * Price AS TotalSum FROM Products ORDER BY TotalSum;
```
В качестве критерия сортировки также можно использовать сложно выражение на основе столбцов:
```sql
SELECT ProductName, Price, ProductCount FROM Products ORDER BY ProductCount * Price;
```
**Сортировка по убыванию**

По умолчанию данные сортируются по возрастанию, однако с помощью оператора `DESC` можно задать сортировку по убыванию.
```sql
SELECT ProductName, ProductCount FROM Products ORDER BY ProductCount DESC;
```
По умолчанию вместо DESC используется оператор ASC, который сортирует по возрастанию:
```sql
SELECT ProductName, ProductCount FROM Products ORDER BY ProductCount ASC;
```
**Сотировка по нескольким столбцам**

При сортировке сразу по нескольким столбцам все эти столбцы указываются через запятую после оператора `ORDER BY`:
```sql
SELECT ProductName, Price, Manufacturer FROM Products ORDER BY Manufacturer, ProductName;
```
Здесь строки сначала сортируются по столбцу Manufacturer по возрастанию. Затем если есть две строки, в которых столбец Manufacturer имеет одинаковое значение, то они сортируются по столбцу ProductName также по возрастанию. Но опять же с помощью `ASC` и `DESC` можно отдельно для разных столбцов определить сортировку по возрастанию и убыванию:
```sql
SELECT ProductName, Price, Manufacturer FROM Products ORDER BY Manufacturer ASC, ProductName DESC;
```

## Получение диапазона строк. Оператор `LIMIT`

Оператор `LIMIT` позволяет извлечь определенное количество строк и имеет следующий синтаксис:

>`LIMIT` [offset,] rowcount

Если оператору `LIMIT` передается один параметр, то он указывает на количество извлекаемых строка. Если передается два параметра, то первый параметр устанавливает смещение относительно начала, то есть сколько строк нужно пропустить, а второй параметр также указывает на количество извлекаемых строк.

```sql
SELECT * FROM Products LIMIT 3;
SELECT * FROM Products LIMIT 2, 3;
```
Как правило, оператор `LIMIT` используетс вместе с оператором `ORBER BY`:
```sql
SELECT * FROM Products ORDER BY ProductName LIMIT 2, 3;
```

## Агрегатные функции

Агрегатные функции вычисляют некоторые скалярные значения в наборе строк. В MySQL есть следующие агрегатные функции:

>`AVG`: вычисляет среднее значение
>
>`SUM`: вычисляет сумму значений
>
>`MIN`: вычисляет наименьшее значение
>
>`MAX`: вычисляет наибольшее значение
>
>`COUNT`: вычисляет количество строк в запросе

Найдем среднюю цену товаров из базы данных:
```sql
SELECT AVG(Price) AS Average_Price FROM Products
```
По умолчанию все вышеперечисленных пять функций учитывают все строки выборки для вычисления результата. Но выборка может содержать повторяющие значения. Если необходимо выполнить вычисления только над уникальными значениями, исключив из набора значений повторяющиеся данные, то для этого применяется оператор `DISTINCT`.
```sql
SELECT COUNT(DISTINCT Manufacturer) FROM Products
```
По умолчанию вместо `DISTINCT` применяется оператор `ALL`, который выбирает все строки:
```sql
SELECT COUNT(ALL Manufacturer) FROM Products
```
Объединим применение нескольких функций:
```sql
SELECT COUNT(*) AS ProdCount,
       SUM(ProductCount) AS TotalCount,
       MIN(Price) AS MinPrice,
       MAX(Price) AS MaxPrice,
       AVG(Price) AS AvgPrice
FROM Products
```

## Группировка

Операторы `GROUP BY` и `HAVING` позволяют сгруппировать данные. Они употребляются в рамках команды `SELECT`:
>`SELECT` столбцы `FROM` таблица [`WHERE` условие_фильтрации_строк] [`GROUP BY` столбцы_для_группировки] [`HAVING` условие_фильтрации_групп]
[`ORDER BY` столбцы_для_сортировки]

Оператор `GROUP BY` определяет, как строки будут группироваться.

Например, сгруппируем товары по производителю. Первый столбец в выражении `SELECT` - Manufacturer представляет название группы, а второй столбец - ModelsCount представляет результат функции `Count`, которая вычисляет количество строк в группе.
```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount FROM Products GROUP BY Manufacturer
```
Следует учитывать, что выражение `GROUP BY` должно идти после выражения `WHERE`, но до выражения `ORDER BY`:
```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount FROM Products WHERE Price > 30000 GROUP BY Manufacturer ORDER BY ModelsCount DESC
```
Оператор `HAVING` позволяет выполнить фильтрацию групп, то есть определяет, какие группы будут включены в выходной результат.

Использование HAVING во многом аналогично применению WHERE. Только есть WHERE применяется для фильтрации строк, то HAVING - для фильтрации групп.

Например, найдем все группы товаров по производителям, для которых определено более 1 модели:
```sql
SELECT Manufacturer, COUNT(*) AS ModelsCount FROM Products GROUP BY Manufacturer HAVING COUNT(*) > 1
```

## Подзапросы

Подзапросы представляют выражения `SELECT`, которые встроены в другие запросы `SQL`. Рассмотрим простейший пример применения подзапросов.

Например, найдем товары из таблицы Products, которые имеют минимальную цену:
```sql
SELECT * FROM Products WHERE Price = (SELECT MIN(Price) FROM Products);
```
Или найдем товары, цена которых выше средней:
```sql
SELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products);
```
**Коррелирующие и некоррелирующие подзапросы**

Подзапросы бывают коррелирующими и некоррелирующими. В примерах выше команды `SELECT` фактически выполняли один подзапрос для всех строк, извлекаемых командой. Например, подзапрос возвращает минимальную или среднюю цену, которая не изменится, сколько бы мы строк не выбирали в основном запросе. То есть результат подзапроса не зависел от строк, которые выбираются в основном запросе. И такой подзапрос выполняется один раз для всего внешнего запроса.

Но также можно использовать и коррелирующие подзапросы (correlated subquery), результаты которых зависят от строк, которые выбираются в основном запросе.

Например, выберем все заказы из таблицы Orders, добавив к ним информацию о товаре:

```sql
SELECT  CreatedAt, Price, 
        (SELECT ProductName FROM Products 
        WHERE Products.Id = Orders.ProductId) AS Product
FROM Orders;
```
В данном случае для каждой строки из таблицы Orders будет выполняться подзапрос, результат которого зависит от столбца ProductId. И каждый подзапрос может возвращать различные данные.

## Подзапросы в основных командах `SQL`

### Подзапросы в `SELECT`

В выражении SELECT мы можем вводить подзапросы четырьмя способами:
>+ В условии в выражении `WHERE`
>
>+ В условии в выражении `HAVING`
>
>+ В качестве таблицы для выборки в выражении `FROM`
>
>+ В качестве спецификации столбца в выражении `SELECT`

Рассмотрим некоторые из этих случаев. Например, получим все товары, у которых цена выше средней:
```sql
SELECT * FROM Products WHERE Price > (SELECT AVG(Price) FROM Products)
```
**Оператор IN**

Нередко подзапросы применяются вместе с оператором `IN`, который выбирает из набора значений. И подзапрос как раз может предоставить требуемый набор значений. Например, выберем все товары из таблицы Products, на которые есть заказы в таблице Orders:
```sql
SELECT * FROM Products WHERE Id IN (SELECT ProductId FROM Orders)
```
То есть подзапрос в данном случае выбирает все идентификаторы товаров из Orders, затем по этим идентификаторам извлекаютя товары из Products.

Добавив оператор `NOT`, мы можем выбрать те товары, на которые нет заказов в таблице Orders:
```sql
SELECT * FROM Products WHERE Id NOT IN (SELECT ProductId FROM Orders)
```
При использовании в операторах сравнения подзапросы должны возвращать одно скалярное значение. Но иногда возникает необходимость получить набор значений. Чтобы при использовании в операторах сравнения подзапрос мог возвращать набор значений, перед ним необходимо использовать один из операторов: `ALL`, `SOME` или `ANY`.

При использовании ключевого слова `ALL` условие в операции сравнения должно быть верно для всех значений, которые возвращаются подзапросом. Например, найдем все товары, цена которых меньше чем у любого товара фирмы Apple:
```sql
SELECT * FROM Products WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')
```
Допустим, если данный подзапрос возвращает значения vаl1, val2 и val3, то условие фильтрации фактически было бы аналогично объединению этих значений через оператор `AND`:
```sql
WHERE Price < val1 AND Price < val2 AND Price < val3
```
В тоже время подобный запрос гораздо проще переписать другим образом:
```sql
SELECT * FROM Products WHERE Price < (SELECT MIN(Price) FROM Products WHERE Manufacturer='Apple')
```
**Подзапрос как спецификация столбца**

Результат подзапроса может представлять отдельный столбец в выборке. Например, выберем все заказы и добавим к ним информацию о названии товара:
```sql
SELECT *, (SELECT ProductName FROM Products WHERE Id=Orders.ProductId) AS Product  FROM Orders
```
### Подзапросы в команде `INSERT`

В команде `INSERT` подзапросы могут применяться для определения значения, которое вставляется в один из столбцов:
```sql
INSERT INTO Orders (ProductId, CreatedAt, ProductCount, Price)
VALUES
( 
    (SELECT Id FROM Products WHERE ProductName='Galaxy S8'),
    '2018-05-23',  
    2, 
    (SELECT Price FROM Products WHERE ProductName='Galaxy S8')
)
```
### Подзапросы в команде `UPDATE`

В команде UPDATE подзапросы могут применяться:
>+ В качестве устанавливаемого значения после оператора `SET`
>
>+ Как часть условия в выражении `WHERE`

Так, увеличим в таблице Orders количество купленных товаров компании Apple на 2:
```sql
UPDATE Orders SET ProductCount = ProductCount + 2 WHERE ProductId IN (SELECT Id FROM Products WHERE Manufacturer='Apple');
```
Или установим для заказа цену товара, полученную в результате подзапроса:
```sql
UPDATE Orders SET Price = (SELECT Price FROM Products WHERE Id=Orders.ProductId) + 3000 WHERE Id=1;
```
### Подзапросы в команде `DELETE`

В команде `DELETE` подзапросы также применяются как часть условия. Так, удалим все заказы на Galaxy S8:
```sql
DELETE FROM Orders WHERE ProductId=(SELECT Id FROM Products WHERE ProductName='Galaxy S8');
```

## Оператор `EXISTS`

Оператор `EXISTS` проверяет, возвращает ли подзапрос какое-либо значение. Как правило, этот оператор используется для индикации того, что как минимум одна строка в таблице удовлетворяет некоторому условию. Поскольку возвращения набора строк не происходит, то подзапросы с подобным оператором выполняются довольно быстро.

Применение оператора имеет следующий формальный синтаксис:
>`WHERE` [NOT] `EXISTS` (подзапрос)

Например, найдем все товары из таблицы Products, на которые есть заказы в таблице Orders:
```sql
SELECT * FROM Products WHERE EXISTS  (SELECT * FROM Orders WHERE Orders.ProductId = Products.Id)
```
Если мы хотим узнать, наоброт, есть ли в таблице строки, которые **НЕ** удовлетворяют условию, то можно использовать операторы `NOT EXISTS`. Например, найдем все товары из таблицы Products, на которые не было заказов в таблице Orders:
```sql
SELECT * FROM Products WHERE NOT EXISTS (SELECT * FROM Orders WHERE Products.Id = Orders.ProductId)
```
Стоит отметить, что для получения подобного результата можно было бы использовать и опеатор `IN`:
```sql
SELECT * FROM Products WHERE Id NOT IN (SELECT ProductId FROM Orders)
```
Но поскольку при применении `EXISTS` не происходит выборка строк, то его использование более оптимально и эффективно, чем использование оператора `IN`.

## Неявное соединение таблиц

Нередко возникает необходимость в одном запросе получить данные сразу из нескольких таблиц. Для сведения данных из разных таблиц мы можем использовать разные способы. В данной статье рассмотрим не самый распространный, однако довольно простой способ, который представляет неявное соединение таблиц.

Cоединим две таблицы Orders и Customers:
```sql
SELECT * FROM Orders, Customers;
```
Но вряд ли это тот результат, который хотелось бы видеть. Тем более к примеру каждый заказ из Orders связан с конкретным покупателем из Customers, а не со всеми возможными покупателями.

Чтобы решить задачу, необходимо использовать выражение `WHERE` и фильтровать строки при условии, что поле CustomerId из Orders соответствует полю Id из Customers:
```sql
SELECT * FROM Orders, Customers WHERE Orders.CustomerId = Customers.Id;
```

## `Inner Join`

Общий формальный синтаксис применения оператора `INNER JOIN`:

>`SELECT` столбцы
`FROM` таблица1
    [`INNER`] `JOIN` таблица2
    `ON` условие1
    [[`INNER`] `JOIN` таблица3
    `ON` условие2]

Используя `JOIN`, выберем все заказы и добавим к ним информацию о товарах:
```sql
SELECT Orders.CreatedAt, Orders.ProductCount, Products.ProductName  FROM Orders JOIN Products ON Products.Id = Orders.ProductId;
```
Поскольку таблицы могут содержать столбцы с одинаковыми названиями, то при указании столбцов для выборки указывается их полное имя вместе с именем таблицы, например, "Orders.ProductCount".

## `Outer Join`

В предыдущей теме рассматривля `Inner Join` или внутреннее соединение таблиц. Но также в MySQL мы можем использовать и так называемое внешнее соединение или `Outer Join.` В отличие от `Inner Join `внешнее соединение возвращает все строки одной или двух таблиц, которые участвуют в соединении.

`Outer Join` имеет следующий формальный синтаксис:

>`SELECT` столбцы
`FROM` таблица1
    {`LEFT`|`RIGHT`} [`OUTER`] `JOIN` таблица2 `ON` условие1
    [{`LEFT`|`RIGHT`} [`OUTER`] `JOIN` таблица3 `ON` условие2]...

Перед оператором `JOIN` указывается одно из ключевых слов `LEFT` или `RIGHT`, которые определяют тип соединения:
>+ `LEFT`: выборка будет содержать все строки из первой или левой таблицы
>
>+ `RIGHT`: выборка будет содержать все строки из второй или правой таблицы

Также перед оператором `JOIN` может указываться ключевое слово `OUTER`, но его применение необязательно. Далее после `JOIN` указывается присоединяемая таблица, а затем идет условие соединения.

Например, соединим таблицы Orders и Customers:
```sql
SELECT FirstName, CreatedAt, ProductCount, Price, ProductId FROM Orders LEFT JOIN Customers ON Orders.CustomerId = Customers.Id
```

**UNION**

Оператор `UNION` позволяет обединить две однотипных выборки. Эти выборки могут быть из разных таблиц или из одной и той же таблицы. Формальный синтаксис объединения:

>`SELECT`_выражение1
`UNION` [`ALL`] `SELECT`_выражение2
[`UNION` [`ALL`] `SELECT`_выражениеN]

К примеру обе таблицы, несмотря на наличие различных данных, могут характеризоваться двумя общими атрибутами - именем (FirstName) и фамилией (LastName). Выберем сразу всех клиентов банка и его сотрудников из обеих таблиц:
```sql
SELECT FirstName, LastName FROM Customers UNION SELECT FirstName, LastName FROM Employees;
```
## Функции для работы со строками

Для работы со строка в MySQL определен ряд встроенных функций:

>`CONCAT`: объединяет строки. В качестве параметра принимает от 2-х и более строк, которые надо соединить:
```sql
SELECT CONCAT('Tom', ' ', 'Smith')  -- Tom Smith
```
При этом в функцию можно передавать не только непосредственно строки, но и числа, даты - они будут преобразовываться в строки и также объединяться.

>`CONCAT_WS`: также объединяет строки, но в качестве первого параметра принимает разделитель, который будет соединять строки:
```sql
SELECT CONCAT_WS(' ', 'Tom', 'Smith', 'Age:', 34)  -- Tom Smith Age: 34
```
>`LENGTH`: возвращает количество символов в строке. В качестве параметра в функцию передается строка, для которой надо найти длину:
```sql
SELECT LENGTH('Tom Smith')  -- 9
```
>`LTRIM`: удаляет начальные пробелы из строки. В качестве параметра принимает строку:
```sql
SELECT LTRIM('  Apple')
```
>`RTRIM`: удаляет конечные пробелы из строки. В качестве параметра принимает строку:
```sql
SELECT RTRIM(' Apple    ')
```
>`TRIM`: удаляет начальные и конечные пробелы из строки. В качестве параметра принимает строку:
```sql
SELECT TRIM('  Tom Smith   ')
```
С помощью дополнительного оператора можно задать где имеено удалить пробелы: 

>`BOTH` (в начале и в конце), `TRAILING` (только в конце), `LEADING` (только в начале):
```sql
SELECT TRIM(BOTH FROM '  Tom Smith   ')
```
>`LOCATE(find, search [, start])`: возвращает позицию первого вхождения подстроки find в строку search. Дополнительный параметр start позволяет установить позицию в строке search, с которой начинается поиск подстроки find. Если подстрока search не найдена, то возвращается 0:
```sql
SELECT LOCATE('om', 'Tom Smith');       -- 2
SELECT LOCATE('m', 'Tom Smith');        -- 3
SELECT LOCATE('m', 'Tom Smith', 4);     -- 6
SELECT LOCATE('mig', 'Tom Smith');      -- 0
```
>`LEFT`: вырезает с начала строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
```sql
SELECT LEFT('Apple', 3) -- App
```
>`RIGHT`: вырезает с конца строки определенное количество символов. Первый параметр функции - строка, а второй - количество символов, которые надо вырезать сначала строки:
```sql
SELECT RIGHT('Apple', 3)    -- ple
```
>`SUBSTRING(str, start [, length])`: вырезает из строки str подстроку, начиная с позиции start. Третий необязательный параметр передает количество вырезаемых символов:
```sql
SELECT SUBSTRING('Galaxy S8 Plus', 8),          -- S8 Plus
(SELECT SUBSTRING('Galaxy S8 Plus', 8, 2) );    -- S8
```
>`SUBSTRING_INDEX(str, delimiter, count)`: вырезает из строки str подстроку. Параметр delimiter определяет разделитель внутри строки. А параметр count определяет, до какого вхождения разделителя надо вырезать подстроку. Если count положительный, то подстрока вырезается с начала, если count отрицательный, то с конца строки str:

```sql
SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', 1),           -- Galaxy
(SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', 2) ),        -- Galaxy S8
(SELECT SUBSTRING_INDEX('Galaxy S8 Plus', ' ', -2) );           -- S8 Plus
```
>`REPLACE(search, find, replace)`: заменяет в строке find подстроку search на подстроку replace. Первый параметр функции - строка, второй - подстрока, которую надо заменить, а третий - подстрока, на которую надо заменить:

```sql
SELECT REPLACE('Galaxy S8 Plus', 'S8 Plus', 'Note 8')   -- Galaxy Note 8
```
>`INSERT(str, start, length, insert)`: вставляет в строку str, заменяя length символов с позиции start подстрокой insert. Первый параметр функции - строка, второй - позиция, с которой надо заменить, третий - сколько символов с позиции start надо заменить вставляемой подстрокой, четвертый параметр - вставляемая подстрока:

```sql
SELECT INSERT('Galaxy S9', 8, 3, 'Note 9');   -- Galaxy Note 9
```
>`REVERSE`: переворачивает строку наоборот:

```sql
SELECT REVERSE('123456789') -- 987654321
```
>`LOWER`: переводит строку в нижний регистр:

```sql
SELECT LOWER('Apple')   -- apple
```
>`UPPER`: переводит строку в верхний регистр

```sql
SELECT UPPER('Apple')   -- APPLE
```
>`SPACE`: возвращает строку, которая содержит определенное количество пробелов

>`REPEATE(str, count)`: возвращает строку, которая содержит определенное количество повторов подстроки str. Количество повторов задается через параметр count.

```sql
SELECT REPEAT('ab', 5);   -- ababababab
```
>`LPAD(str, length, pad)`: добавляет слева от строки str некоторое количество символов, которые определены в параметре pad. Количество добавляемых символов вычисляется по формуле length - `LENGTH(str)`. Если параметр length меньше длины строки str, то эта строка усекается до length символов.

```sql
SELECT LPAD('Tom Smith', 13, '*');   -- ****Tom Smith
```
>`RPAD(str, length, pad)`: добавляет справа от строки str некоторое количество символов, которые определены в параметре pad. Количество добавляемых символов вычисляется по формуле length - `LENGTH(str)`. Если параметр length меньше длины строки str, то эта строка усекается до length символов.

```sql
SELECT RPAD('Tom Smith', 13, '*');   -- Tom Smith****
```

## Функции для работы с числами

Для работы с числовыми данными MySQL предоставляет ряд функций:

>`ROUND`: округляет число. В качестве первого параметра передается число. Второй параметр указывает на длину. Если длина представляет положительное число, то оно указывает, до какой цифры после запятой идет округление. Если длина представляет отрицательное число, то оно указывает, до какой цифры с конца числа до запятой идет округление

```sql
SELECT ROUND(1342.345, 2),      -- 1342.35
(SELECT ROUND(1342.345, -2));   -- 1300;
```
>`TRUNCATE`: оставляет в дробной части определенное количество символов

```sql
SELECT TRUNCATE(1342.345, 2);       -- 1342.34
```
>`ABS`: возвращает абсолютное значение числа.

```sql
SELECT ABS(-123)    -- 123
```
>`CEILING`: возвращает наименьшее целое число, которое больше или равно текущему значению.

```sql
SELECT CEILING(-123.45),        -- -123
(SELECT CEILING(123.45));       -- 124
```
>`FLOOR`: возвращает наибольшее целое число, которое меньше или равно текущему значению.

```sql
SELECT FLOOR(-123.45),      -- -124
(SELECT FLOOR(123.45));     -- 123
```
>`POWER`: возводит число в определенную степень.

```sql
SELECT POWER(5, 2),     -- 25
(SELECT POWER(5, 3));       -- 125
```
>`SQRT`: получает квадратный корень числа.

```sql
SELECT SQRT(225);       -- 15
```
>`SIGN`: возвращает -1, если число меньше 0, и возвращает 1, если число больше 0. Если число равно 0, то возвращает 0.

```sql
SELECT SIGN(-5),        -- -1
(SELECT SIGN(7));       -- 1
```
>`RAND`: генерирует случайное число с плавающей точкой в диапазоне от 0 до 1.

```sql
SELECT RAND();      -- 0.707365088352935
SELECT RAND();      -- 0.173808327956812
```

## Функции для работы с датами и временем

MySQL имеет ряд встроенных функций для работы с датами и временем.

### Получение даты и времени
Функции `NOW()`, `SYSDATE()`, `CURRENT_TIMESTAMP()` возвращают текущую локальную дату и время на основе системных часов в виде объекта datetime. Все три функции возвращают одинаковый результат

```sql
SELECT NOW();               -- 2018-05-25 21:34:55
SELECT SYSDATE();           -- 2018-05-25 21:34:55
SELECT CURRENT_TIMESTAMP(); -- 2018-05-25 21:32:55
```
Функции `CURDATE` и `CURRENT_DATE` возвращают текущую локальную дату в виде объекта date:

```sql
SELECT CURRENT_DATE();      -- 2018-05-25
SELECT CURDATE();           -- 2018-05-25
```
Функции `CURTIME` и `CURRENT_TIME` возвращают текущее время в виде объекта time:

```sql
SELECT CURRENT_TIME();  -- 20:47:45
SELECT CURTIME();       -- 20:47:45
```
`UTC_DATE` возвращает текущую локальную дату относительно GMT

```sql
SELECT UTC_DATE();      -- 2018-05-25
```
`UTC_TIME` возвращает текущее локальное время относительно GMT

```sql
SELECT UTC_TIME();      -- 17:47:45
```
### Парсинг даты и времени
>`DAYOFMONTH(date)` возвращает день месяца в виде числового значения
>
>`DAYOFWEEK(date)` возвращает день недели в виде числового значения
>
>`DAYOFYEAR(date)` возвращает номер дня в году
>
>`MONTH(date)` возвращает месяц даты
>
>`YEAR(date)` возвращает год из даты
>
>`QUARTER(date)` возвращает номер квартала года
>
>`WEEK(date [, first])` возвращает номер недели года. Необязательный параметр позволяет задать стартовый день недели. Если этот параметр равен 1, то первым днем считается понедельник, иначе воскресенье
>
>`LAST_DAY(date)` возвращает последний день месяца в виде даты
>
>`DAYNAME(date)` возвращает название дня недели
>
>`MONTHNAME(date)` возвращает название текущего месяца
>
>`HOUR(time)` возвращает час времени
>
>`MINUTE(time)` возвращает минуту времени
>
>`SECOND(time)` возвращает секунду времени

**Функция EXTRACT**

Функция `EXTRACT` извлекает из даты и времени какой-то определенный компонент. Ее формальный синтаксис:
```sql
EXTRACT(unit FROM datetime)
```
Значение datetime представляет исходную дату и (или) время, а значение unit указывает, какой компонент даты или времени будет извлекаться. Параметр unit может представлять одно из следующих значений:

>`SECOND` (секунды)
>
>`MINUTE` (минуты)
>
>`HOUR` (час)
>
>`DAY` (день)
>
>`MONTH` (месяц)
>
>`YEAR` (год)
>
>`MINUTE_SECOND` (минуты и секунды)
>
>`HOUR_MINUTE` (часы и минуты)
>
>`DAY_HOUR` (день и часы)
>
>`YEAR_MONTH` (год и месяц)
>
>`HOUR_SECOND` (часы, минуты и секунды)
>
>`DAY_MINUTE` (день, часы и минуты)
>
>`DAY_SECOND` (день, чаы, минуты и секунды)

**Функции для манипуляции с датами**

Ряд функций позволяют производить операции сложения и вычитания с датами и временем:

>`DATE_ADD(date, INTERVAL expression unit)` возвращает объект DATE или DATETIME, который является результатом сложения даты date с определенным временным интервалом. Интервал задается с помощью выражения INTERVAL expression unit, где INTERVAL предоставляет ключевое слово, expression - количество добавляемых к дате единиц, а unit - тип единиц (часы, дни и т.д.) Параметр unit может иметь те же значения, что и в функции EXTRACT, то есть DAY, HOUR и т.д.
>
>`DATE_SUB(date, INTERVAL expression unit)` возвращает объект DATE или DATETIME, который является результатом вычитания из даты date определенного временного интервала
>
>`DATEDIFF(date1, date2)` возвращает разницу в днях между датами date1 и date2
>
>`TO_DAYS(date)` возвращает количество дней с 0-го года
>
>`TIME_TO_SEC(time)` возвращает количество секунд, прошедших с момента полуночи

**Форматирование дат и времени**

>`DATE_FORMAT(date, format)` возвращает объект DATE или DATETIME, отформатированный с помощью шаблона format
>
>`TIME_FORMAT(date, format)` возвращает объект TIME или DATETIME, отформатированный с помощью шаблона format

Обе функции в качестве второго параметра принимают строку форматирования или шаблон, который показывает, как оформатировать значение. Этот шаблон может принимать следующие значения:

>+ `%m`: месяц в числовом формате 01..12
>
>+ `%с`: месяц в числовом формате 1..12
>
>+ `%M`: название месяца (January...December)
>
>+ `%b`: аббревиатура месяца (Jan...Dec)
>
>+ `%d`: день месяца в числовом формате 00..31
>
>+ `%e`: день месяца в числовом формате 0..31
>
>+ `%D`: номер дня месяца с суффиксом (1st, 2nd, 3rd...)
>
>+ `%y`: год в виде двух чисел
>
>+ `%Y`: год в виде четырех чисел
>
>+ `%W`: название дня недели (Sunday...Saturday)
>
>+ `%a`: аббревиатура дня недели (Sun...Sat)
>
>+ `%H`: час в формате 00..23
>
>+ `%k`: час в формате 0..23
>
>+ `%h`: час в формате 01..12
>
>+ `%l`: час в формате 1..12
>
>+ `%i`: минуты в формате 00..59
>
>+ `%r`: время в 12-ти часовом формате (hh:mm:ss AM или PM)
>
>+ `%T`: время в 24-ти часовом формате (hh:mm:ss)
>
>+ `%S`: секунды в формате 00..59
>
>+ `%p`: AM или PM

## Функции `CASE`, `IF`, `IFNULL`, `COALESCE`

### Функция `CASE`

Функция `CASE` проверяет истинность набора условий и в зависимости от результата проверки может возвращать тот или иной результат. Эта функция принимает следующую форму:
>`CASE`
>
>`WHEN` условие_1 `THEN` результат_1
>
>`WHEN` условие_2 `THEN` результат_2
> 
>.................................
> 
>`WHEN` условие_N `THEN` условие_N
>
> [`ELSE` альтернативный_результат]
> 
>`END`

Возьмем для примера следующую таблицу Products и выполним запрос к этой таблице и используем функцию `CASE`:
```sql
SELECT ProductName, ProductCount, 
CASE
    WHEN ProductCount = 1 
        THEN 'Товар заканчивается'
    WHEN ProductCount = 2 
        THEN 'Мало товара'
    WHEN ProductCount = 3 
        THEN 'Есть в наличии'
    ELSE 'Много товара'
END AS Category
FROM Products;
```
### Функция `IF`

Функция `IF` в зависимости от результата условного выражения возвращает одно из двух значений. Общая форма функции выглядит следующим образом:

>`IF`(условие, значение_1, значение_2)

Если условие, передаваемое в качестве первого параметра, верно, то возвращается первое значение, иначе возвращается второе значение. Например:

```sql
SELECT ProductName, Manufacturer,
    IF(ProductCount > 3, 'Много товара', 'Мало товара')
FROM Products;
```

### Функция `IFNULL`

Функция `IFNULL` проверяет значение некоторого выражения. Если оно равно `NULL`, то функция возвращает значение, которое передается в качестве второго параметра:

>`IFNULL`(выражение, значение)

```sql
SELECT FirstName, LastName,
    IFNULL(Phone, 'не определено') AS Phone,
    IFNULL(Email, 'неизвестно') AS Email
FROM Clients;
```

### Функция `COALESCE`

Функция `COALESCE` принимает список значений и возвращает первое из них, которое не равно `NULL`:

>`COALESCE`(выражение_1, выражение_2, выражение_N)

Например, выберем из таблицы Clients пользователей и в контактах у них определим либо телефон, либо электронный адрес, если они не равны NULL:

```sql
SELECT FirstName, LastName,
    COALESCE(Phone, Email, 'не определено') AS Contacts
FROM Clients;
```